<html dir="rtl" lang="fa"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ چهارم</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css">
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css">
	<link rel="stylesheet" href="css/syntax.css" type="text/css">
  	<link rel="stylesheet" href="css/main.css" type="text/css">
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ چهارم (دوشنبه ۲۸ بهمن ۹۸ )</h3><br>
<p class="myjustify">
</p><ul>
<li>
    مرتب سازی ادغامی in place نیست.
      </li>
      <li>
          مثالی از نحوه ی انجام گیری مرتب سازی ادغامی
      </li>
      <li>
          تحلیل زمانی مسائل تقسیم و حل عموما به صورت بازگشتی می باشد.
      </li>
      <li>
    قضیۀ اصلی برای حل روابط بارگشتی (T(n)=aT(n/b)+f(n
</li>
<ul>
    <li>
        تعداد برگ‌های درخت بازگشتی L=n<sup>log<sub>b</sub>a</sup>
        و ارتفاع درخت h=log<sub>b</sub>n
    </li>
    <li>
        ۱. اگر (f(n)=O(L<sup>1-ε</sup> باشد، داریم (T(n)=Θ(L.
    </li>
    <li>
        ۲. اگر (f(n)=Θ(L log<sup>k</sup>n داریم (T(n)=Θ(L log<sup>k+1</sup>n.
    </li>
    <li>
        ۳. اگر (f(n)=Ω(L<sup>1+ε</sup> باشد، داریم ((T(n)=Θ(f(n.
    </li>
</ul>
<li>
    برتری‌های مرتب‌سازی درجی نسبت به ادغامی
</li>
<ul>
    <li>
        ۱. حافظۀ اضافه مصرف نمی‌کند. برای حل مشکل حافظۀ اضافۀ مرتب‌سازی ادغامی، الگوریتم مرتب‌سازی خارجی
        ارائه شده است که مشابه مرتب‌سازی ادغامی است ولی با حافظی اضافیِ محدود. زمان مرتب‌سازی خارجی ۲ تا ۳
        برابر بیشتر است و در عمل استفاده نمی‌شود.
</li>
    <ul>
        <li>
            مرتب‌سازی درجی با تنها یک متغیر اضافه نیز قابل پیاده‌سازی است که توسط دکتر سربازی‌آزاد برای
            اولین بار انجام شده است (با نام stupid sort) و بعداً به نام genome sort نیز معرفی شده است.
        </li>
    </ul>
    <li>
        ۲. در حالتی که ورودی (تقریباً) مرتب است، مرتب‌سازی درجی زمان (Θ(n دارد ولی مرتب‌سازی درجی زمان (Θ(n
        log n.
    </li>
</ul>
<li>
    مرتب‌سازی در پایتون، اندروید و جاوا (برای مرتب‌سازی کلاس‌ها و نه اعداد) با الگوریتم مرتب‌سازی
    تیم (TimSort) انجام می‌شود.
    این مرتب‌سازی ترکیبی از مرتب‌سازی‌های درجی و ادغامی است.
</li>
<ul>
    <li>
        با وجود این که اولین مقاله درباره ی این روش در سال ۱۹۹۳ ارائه شد، اما این مرتب‌سازی بالاخره در سال ۲۰۰۲ و برای زبان پایتون توسط تیم پیتر طراحی شد. در ابتدا بر روی این که طراحی مرتب‌سازی
        تیم، خارج از فضای آکادمیک انجام شده تبلیغاتی صورت گرفت. ولی در سال ۲۰۱۵ یک باگ به واسطۀ تلاش برای اثبات صوری این
        الگوریتم در فضای آکادمیک (پس از ۱۳ سال) پیدا شد.
    </li>
    <li>
        مرتب‌سازی تیم برای زیرآرایه‌های به طول ۶۴ و کمتر از مرتب‌سازی درجی دودویی استفاده می‌شود
        (توضیح در قسمت مقایسۀ زمان واقعی اجرا).
    </li>
    <li>روش این مرتب سازی : ابتدا بخش های مرتب شده آرایه (چه صعودی و چه نزولی) را پیدا میکند. سپس این بخش های مرتب شده را جداکرده و بر مبنای مورد نظر (صعودی با نزولی) با یک for ساده مرتب می کند. پس از اینکه قطعه های مرتب شده جدا شدند، قسمت های باقیمانده sort می شوند.روش sort طبق موارد گفته شده در بالا انتخاب می شود.</li>
    <li>
        مرتب‌سازی تیم، از مرتب‌سازی ادغامی استفاده می‌کند و این قسمت‌ها را با هم ادغام می‌کند.
    </li>
</ul>
</ul></div>
</body></html>