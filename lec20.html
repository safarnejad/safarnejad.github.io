<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ بیست و پنجم</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
	<link rel="stylesheet" href="css/syntax.css" type="text/css" />
  	<link rel="stylesheet" href="css/main.css" type="text/css" />
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ بیست و پنجم (دوشنبه ۲ دی ۹۸)</h3><br/>
<p class="myjustify">
<ul>
<li>
یادآوری جست‌وجوی سطح اول و کوتاهترین مسیر در گراف بدون وزن
</li>
<li>
کاربردها
</li>
<ul>
<li>
مسیریابی نقشه گوگل و waze
</li>
<li>
مسیریابی شبکه
</li>
</ul>
<li>
تعریف دقیق گراف‌های وزن‌دار و داده‌ساختار مربوط به آن
</li>
<ul>
<li>
تعریف دقیق مسیر و وزن یک مسیر (جمع وزن یال‌ها)
</li>
<li>
تعریف دقیق کوتاهترین مسیر بین دو رأس
<span dir="ltr">(δ(u,v))</span>
</li>
<li>
حالتی که مسیری بین آن دو رأس وجود نداشته باشد.
</li>
<li>
مثال در یک گراف ۴ رأسی که کوتاهترین مسیر لزوماً کمترین تعداد یال را نیز ندارد.
</li>
</ul>
<li>
دور منفی و مشکلات آن
</li>
<ul>
<li>
مثال دور منفی و اثر آن روی کوتاهترین مسیر
</li>
<li>
باعث می‌شود کوتاهترین مسیر (گشت) عملاً وجود نداشته باشد زیرا روی دور می‌توان چند بار چرخید و بعد به مسیر اصلی ادامه داد.
</li>
<li>
اصلاح تعریف دقیق کوتاهترین مسیر بین دو رأس در صورت وجود دور منفی (تغییر min به inf)
</li>
<li>
چگونه وجود دور منفی را بررسی کنیم و یک دور منفی (در صورت وجود) پیدا کنیم؟
</li>
</ul>
<li>
دسته‌بندی مسائل کوتاهترین مسیر
</li>
<ul>
<li>
کوتاهترین مسیر بین یک جفت رأس
</li>
<ul>
<li>
روش‌هایی که می‌شناسیم در بدترین حالت مشابه مسئلۀ بعدی هستند.
</li>
</ul>
<li>
کوتاهترین مسیر از یک رأس به بقیۀ رأس‌ها (درخت کوتاهترین مسیر)
</li>
<ul>
<li>
این مسئله در این جلسه و دو جلسۀ بعد مورد بررسی قرار می‌گیرد.
</li>
</ul>
<li>
کوتاهترین مسیر بین هر جفت رأس
</li>
<ul>
<li>
در درس طراحی الگوریتم‌ها مورد بررسی قرار می‌گیرد.
</li>
</ul>
</ul>
<li>
الگوریتم پیدا کردن کوتاهترین مسیر از یک رأس به بقیۀ رأس‌ها
</li>
<li>
الگوریتم‌های ساده جواب نمی‌دهند زیرا تعداد مسیرها در بیشتر مواقع بسیار زیاد (نمایی) است.
</li>
<li>
۴ الگوریتم معروف برای این کار وجود دارد:
</li>
<ul>
<li>
جست‌وجوی سطح اول (جلسه ۲۰) - برای وقتی که وزن نداریم (یا وزن همۀ یال‌ها برابر است) - زمان اجرا 
(Θ(n+e
</li>
<li>
کوتاهترین مسیرها در DAG (این جلسه) - برای وقتی گراف جهت‌دار و بدون دور باشد - زمان اجرا
(Θ(n+e
</li>
<li>
الگوریتم دایسترا (جلسه ۲۴) - برای وقتی وزن یال‌ها نامنفی است - زمان اجرا
(Θ(n log n + e
</li>
<li>
الگوریتم بلمن-فورد (جلسه ۲۳) - در حالت کلی (بدون دور منفی) - زمان اجرا
(Θ(ne
</li>
</ul>
<li>
کوتاهترین مسیرها تشکیل یک درخت می‌دهند که به درخت کوتاهترین مسیر معروف است.
</li>
<ul>
<li>
ایدۀ اثبات این ادعا با استفاده از «زیرساختار بهینه» و جاگذاری مسیرها
</li>
</ul>
<li>
کلیت الگوریتم‌های کوتاهترین مسیر از یک رأس به بقیۀ رأس‌ها (ایدۀ relax کردن(
</li>
<ul>
<li>
هدف پیدا کردن
[d[v
 برابر با کوتاهترین مسیر از s به v است.
</li>
<li>
در طول اجرای الگوریتم
[d[v
بزرگتر مساوی این مقدار است.
این شرط ناوردا (invariant) نامیده می‌شود.
</li>
<li>
در ابتدا
[d[s
را صفر و 
[d[vها
را برابر 
∞
قرار می‌دهیم.
</li>
<li>
relax
کردن یال
(u, v)
به این معنی است که اگر
<span dir="ltr">d[v] > d[u] + w(u,v)</span>
باشد،
[d[v
را به‌روزرسانی می‌کنیم.
دلیل درستی این کار را می‌توان با نامساوی مثلث روی کوتاهترین مسیرها نشان داد.
</li>
<li>
این که به چه ترتیبی یال‌ها را relax کنیم اهمیت دارد. اگر به ترتیب اشتباه انجام دهیم، حتی در DAG زمان الگوریتم نمایی می‌شود.
</li>
<li>
وقتی یالی را نتوان relax کرد کار تمام می‌شود.
</li>
<li>
relax
کردن از این‌جا آمده است که ابتدا می‌گذاریم 
[d[vها
شرط اصلی را نقض کنند و مرحله به مرحله آن‌ها را بهبود می‌دهیم.
</li>
</ul>
<li>
الگوریتم کوتاهترین مسیر در DAG
</li>
<ul>
<li>
ایدۀ اصلی این است که از مرتب‌سازی توپولوژیک برای ترتیب relax کردن استفاده کنیم.
</li>
<li>
به هر رأس می‌رسیم یال‌های خروجی آن را relax کنیم، یعنی فاصلۀ s تا آن‌ها را به‌روز کنیم.
</li>
<li>
توجه کنید DAG فاقد دور است و بنابراین مشکل دور منفی وجود ندارد.
</li>
</ul>
<li>
اثبات درستی الگوریتم
</li>
<ul>
<li>
لم ایمنی: با relax کردن، شرط ناوردا حفظ می‌شود.
</li>
<li>
ناوردای قوی: در هر لحظه
[d[v
طول یک مسیر از s به v است.
</li>
<ul>
<li>
اثبات درستی این ادعا
</li>
<li>
با استفاده از ناوردای قوی می‌توان درستی این راه را نشان داد.
</li>
</ul>
</ul>
<li>
راه دیگری نیز وجود دارد که در چارچوب گفته شده نیست. پس از مرتب سازی توپولوژیک، به هر رأس می‌رسیم، کوتاهترین مسیر از s به آن را می‌خواهیم حساب کنیم. برای این کار یال‌های ورودی را در نظر می‌گیریم و با استفاده از آن‌ها این مقدار را حساب می‌کنیم. اثبات با استقرای قوی انجام می‌شود. برای این الگوریتم، همسایه‌های ورودی یک رأس (برعکس Adj) را باید ذخیره‌سازی کنیم.
</li>
</ul>
</p>
</div>
</body>
</html>
