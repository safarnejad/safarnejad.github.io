<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ سیزدهم</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
	<link rel="stylesheet" href="css/syntax.css" type="text/css" />
  	<link rel="stylesheet" href="css/main.css" type="text/css" />
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ سیزدهم (دوشنبه ۱۸ فروردین ۹۹)</h3><br/>
<p class="myjustify">
<ul>
<li>
اولین جلسه با موضوع درهم‌سازی: پرکاربردترین داده‌ساختار در علوم و مهندسی کامپیوتر
</li>
<li>
مسئلۀ لغت‌نامه (واسط): به دنبال داده‌ساختاری هستیم که بر روی تعدادی شیء که هر شیء یک کلید خاص دارد عملیات زیر را انجام دهد: 
</li>
<ul>
<li>
درج شیء: یک شیء و کلید آن را بگیرد و آن‌ها را ذخیره کند.
</li>
<li>
حذف شیء: یک کلید را بگیرد و شیء مربوط به آن کلید را حذف کند.
</li>
<li>
جست‌وجوی شیء: یک کلید را بگیرد و در صورت وجود یک شیء با این کلید، آن شیء را برگرداند.
</li>
<li>
فرض می‌کنیم که کلیدها متمایز هستند (یعنی اگر دو شیء را با کلید یکسان درج کنیم، شیء جدید جایگزین شیء قبلی می‌شود).
</li>
<li>
یک درخت دودویی جست‌وجو می‌تواند این مسئله را حل کند و زمان اجرای هر عمل (O(log n خواهد بود.
</li>
<li>
درخت دودویی جست‌وجو علاوه بر این کارها، می‌تواند عناصر با کلید نزدیک (مثل کمترین کلید بزرگ‌تر و بیشترین کلید کوچک‌تر) را نیز پیدا کند.
</li>
<li>
هدف این است که این کارها در (O(1 انجام شوند.
</li>
</ul>
<li>
در زبان پایتون dict این مسئله را حل می‌کند. (دستورهای مرتبط با dict بررسی شدند) 
</li>
<ul>
<li>
همچنین set در پایتون همان dict است با این تفاوت که شیءها همان کلیدها هستند.
</li>
</ul>
<li>
برخی کاربردهای درهم‌سازی
</li>
<ul>
<li>
زبان‌های برنامه‌نویسی
</li>
<li>
پایگاه‌های داده
</li>
<li>
کامپایلرها و مفسرها
</li>
<li>
مسیریاب‌های شبکه (اختصاص خروجی به هم IP)
</li>
<li>
سرورهای شبکه (نگاشت پورت به سوکت/برنامه)
</li>
<li>
حافظه مجازی در سیستم‌عامل‌ها
</li>
<li>
جست‌وجوی زیررشته (دستور grep و جست‌وجوی گوگل)
</li>
<li>
تشابه رشته‌ها (DNA)
</li>
<li>
همگام‌سازی فایل‌ها و شاخه‌ها (دراپ‌باکس)
</li>
<li>
رمزنگاری
</li>
</ul>
<li>
یک راه (غیرمنطقی) برای حل مسئله این است که از کلیدها به عنوان اندیس آرایه استفاده کنیم. در این صورت درج و جست‌وجو در 
<span dir="ltr">O(1)</sub></span>
انجام می‌شود. به این روش جدول دسترسی مستقیم می‌گویند. این روش دو مشکل عمده دارد:
</li>
<ul>
<li>
۱. کلیدها باید اعداد صحیح نامنفی باشند.
</li>
<li>
۲. کلیدهای بزرگ (مثلاً ۲<sup>۲۵۶</sup>) باعث می‌شوند اندازۀ جدول بیش از اندازه بزرگ شود.
</li>
<li>
در ادامه به حل این دو مشکل می‌پردازیم.
</li>
</ul>
<li>
راه‌حل مشکل اول: پیش‌درهم‌سازی
</li>
<ul>
<li>
در کامپیوتر همه‌چیز به صورت صفر و یک ذخیره می‌شوند، پس می‌توان هر کلیدی را به عدد تبدیل کرد. از لحاظ ریاضی نیز مجموعۀ کلیدها شمارا است.
</li>
<li>
در پایتون این کار توسط تابع hash انجام می‌شود (اسم این تابع گمراه‌کننده است و بهتر بود prehash باشد).
</li>
<li>
در تئوری باید پیش‌درهم‌سازی دو کلید متفاوت، متفاوت باشد. اما در پایتون این خاصیت برقرار نیست.
<br/>
<span dir="ltr">hash('\0B')=hash('\0\0C')=64</sub></span>
</li>
<li>
باید توجه کنیم کلیدها در طول اجرای برنامه تغییر نکنند. به طور مثال لیست نمی‌تواند یک کلید باشد چون درج در آن لیست را تغییر می‌دهد.
</li>
</ul>
<li>
راه‌حل مشکل دوم: درهم‌سازی
</li>
<ul>
<li>
مجموعۀ کلیدها (𝒰) را به یک مجموعۀ کوچکتر به اندازۀ m کاهش می‌دهیم.
</li>
<li>
<span dir="ltr">h: 𝒰→{0, 1, ..., m-1}</span>
که m≈n (در این‌جا n تعداد اشیاء است).
</li>
</ul>
<li>
مشکل برخورد
</li>
<ul>
<li>
اگر بخواهیم x را در جایگاه (h(x درج کنیم، ممکن است دو شیء با کلیدهای متفاوت بخواهند در یک خانه درج شوند. این موضوع برخورد نام دارد. 
</li>
<li>
در این جلسه و دو جلسۀ بعد روش‌های مختلف رفع مشکل برخورد بررسی می‌شوند.
</li>
</ul>
<li>
استفاده از زنجیره برای حل مشکل برخورد
</li>
<ul>
<li>
راحت‌ترین راه برای حل مشکل برخورد استفاده از زنجیره است. در این راه اشیائی که برخورد دارند در یک لیست پیوندی ذخیره می‌شوند.
</li>
<li>
برای جست‌وجوی x باید کل لیست مربوط به خانۀ (h(x را بگردیم.
</li>
<li>
درج راحت است و کافی است x را در انتهای لیست پیوندی مربوط به خانۀ (h(x اضافه کنیم.
</li>
<li>
جست‌وجو در بدترین حالت می‌تواند (Θ(n باشد. به دنبال تحلیل حالت میانگین هستیم.
</li>
</ul>
<li>
فرض درهم‌سازی یکنواخت ساده
</li>
<ul>
<li>
فرض می‌کنیم که درهم‌سازی هر کلید با احتمال مساوی و مستقل از بقیۀ کلیدها به هر کدام از خانه‌های جدول نگاشته می‌شود.
</li>
<li>
ضریب بارگذاری α را برابر با n/m تعریف می‌کنیم.
توجه کنید n تعداد کلیدهای ذخیره‌شده در جدول و m اندازۀ جدول است.
</li>
<li>
توجه کنید این فرض لزوماً درست نیست.
</li>
</ul>
<li>
تحلیل روش زنجیره با استفاده از فرض درهم‌سازی یکنواخت ساده
</li>
<ul>
<li>
میانگین زمان جست‌وجو با این فرض برابر با
<span dir="ltr">O(1+α)</span>
است.
</li>
<li>
بنابراین اگر داشته باشیم
<span dir="ltr">m=Ω(n)</span>
زمان جست‌وجو 
<span dir="ltr">O(1)</span>
خواهد بود.
</li>
</ul>
<li>
درهم‌سازی پویا
</li>
<ul>
<li>
با توجه به این که از ابتدا n می‌تواند مشخص نباشد، انتخاب m مناسب به صورتی که 
<span dir="ltr">m=Ω(n)</span>
باشد یک مسئلۀ مهم است.
</li>
<li>
برای این کار مشابه آرایۀ پویا (جلسۀ چهارم) عمل می‌کنیم. هر گاه m=n شد، m را دوبرابر می‌کنیم و هر گاه m=4n شد، m را نصف می‌کنیم.
</li>
<li>
در این صورت همیشه داریم
n≤m≤4n.
</li>
<li>
همچنین زمان سرشکن درج و حذف <span dir="ltr">O(1)</span> است. تحلیل مشابه آرایۀ پویا است.
</li>
</ul>
</ul>
</p>
</div>
</body>
</html>
