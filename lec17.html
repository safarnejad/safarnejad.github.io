<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ بیست و دوم</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
	<link rel="stylesheet" href="css/syntax.css" type="text/css" />
  	<link rel="stylesheet" href="css/main.css" type="text/css" />
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ هفدهم (دوشنبه ۱ اردیبهشت ۹۹)</h3><br/>
<p class="myjustify">
<ul>
<!-- <hr/> -->
<li>
یادآوری گراف:
(G = (V, E
</li>
<ul>
<li>
V 
مجموعۀ رأس‌ها است
</li>
<li>
E
مجموعۀ یال‌ها است
</li>
<ul>
<li>
اگر گراف جهت‌دار باشد، هر یال یک زوج مرتب از دو رأس است.
</li>
<li>
اگر گراف بدون جهت باشد، هر یا یک زیرمجموعۀ دوتایی از رأس‌ها است.
</li>
</ul>
<li>
مثالی از گراف‌های جهت‌دار و بدون جهت
</li>
</ul>
<li>
پیمایش گراف
</li>
<ul>
<li>
پیدا کردن مسیر از رأس داده شدۀ s به یک رأس مشخص دیگر
</li>
<li>
بازدید همۀ رأس‌ها یا یال‌های گراف که از رأس s قابل دسترسی هستند.
</li>
</ul>
<li>
کاربردهای پیمایش گراف
</li>
<ul>
<li>
خزیدن وب (web crawling) مشابه روشی که گوگل صفحات جدید وب را شناسایی می‌کند.
</li>
<li>
شبکه‌های اجتماعی (پیمایش شبکه دوستی و پیشنهاد دوستان در فیس‌بوک و اینستاگرام)
</li>
<li>
مسیریابی (نقشۀ گوگل و waze)
</li>
<li>
پیدا کردن پروازهای غیرمستقیم
</li>
<li>
زباله روبی (garbage collection) در زبان‌های برنامه‌نویسی
</li>
<li>
چک کردن مدل (در علوم کامپیوتر، اقتصاد و کاربردهای حساس)
</li>
<li>
حل برخی پازل‌ها مثل مکعب روبیک ۲ در ۲ در ۲
</li>
<li>
شواهد دیجیتال
</li>
</ul>
<li>
داده‌ساختار مناسب برای ذخیره کردن گراف
</li>
<ul>
<li>
فرض کنید رأس‌ها با اعداد ۱ تا n شماره‌گذاری شده‌اند.
</li>
<li>
ماتریس مجاورت
</li>
<ul>
<li>
یک ماتریس دو بعدی A که 
A[i,j] = 1
است اگر و تنها اگر
i,j) ∈ E).
</li>
<li>
اضافه و کم کردن یال‌ها به سادگی انجام می‌شود. بررسی وجود یک یال نیز به سادگی انجام می‌شود.
</li>
<li>
اما لیست کردن همسایه‌های یک رأس
(Θ(n
طول می‌کشد. همچنین حافظه این روش
(Θ(n<sup>2</sup>
است.
</li>
</ul>
<li>
لیست مجاورت - روش بهتر
</li>
<ul>
<li>
برای هر رأس u لیست همسایه‌های آن (Adj(u را نگه‌داری می‌کنیم. در گراف‌های جهت‌دار یال‌های خروجی را درنظر می‌گیریم.
</li>
<li>
مجموع اندازۀ لیست‌ها در گراف‌های بدون جهت 2E و در گراف‌های جهت‌دار E است. در مجموع حافظۀ این روش
(Θ(n+e
است.
</li>
<li>
به جای لیست می‌توان از جدول درهم‌سازی استفاده کرد و با این روش اضافه و حذف کردن یال و بررسی وجود یک یال نیز در
(Θ(1
انجام می‌شود. همسایه‌های یک رأس نیز در کمترین زمان (تعداد همسایه‌ها) انجام می‌شود.
</li>
</ul>
<li>
روش شیء‌گرا: به جای 
[Adj[u
 داشته باشیم
u.neighbors
</li>
<ul>
<li>
در روش غیر شیءگرا می‌توان روی رئوس دو گراف مختلف داشت.
</li>
</ul>
<li>
در گراف صریح اطلاعات از ابتدا موجود است ولی در گراف ضمنی اطلاعات  
([Adj[u)
موجود نیست و وقتی نیاز داریم محاسبه می‌شود.
</li>
<li>
جست‌وجوی سطح اول یا سطح به سطح (BFS)
</li>
<ul>
<li>
گراف را از یک رأس به صورت سطح به سطح پیمایش می‌کند. هر سطح یک لایه نیز نامیده می‌‌شود.
</li>
<li>
در هم مرحله یک مجموعۀ مرزی (frontier) داریم که آخرین لایۀ پیمایش شده است.
</li>
<li>
با بررسی رأس‌های مجموعۀ مرزی، ‌همسایه‌هایی که تاکنون پیمایش نشده‌اند را در لایۀ بعدی (next) قرار می‌دهیم.
</li>
<li>
در مرحلۀ بعد، مجموعۀ مرزی جدید را برابر next قرار می‌دهیم.
</li>
<li>
وقتی کار تمام می‌شود که مجموعۀ بعدی (یا مجموعۀ مرزی) تهی شود.
</li>
<li>
کد نمونه (با روش CLRS که از صف استفاده می‌کند متفاوت است):
<pre dir="ltr" align="left">
BFS(V, Adj, s):
  level = {s: 0}
  parent = {s: None}
  i = 1
  frontier = [s]
  while frontier:
    next = []
    for u in frontier:
      for v in Adj[u]:
        if v not in level:
          level[v] = i
          parent[v] = u
          next.append(v)
    frontier = next
    i += 1
</pre>
</li>
<li>
مثال اجرای مرحله به مرحلۀ الگوریتم روی یک گراف ۸ رأسی
</li>
<li>
مرتبۀ زمانی الگوریتم برابر است با
(Θ(n+e
چون هر رأس یک بار به frontier وارد می‌شود و یک بار Adj آن بررسی می‌شود. همچنین می‌دانیم جمع Adjها برابر است با
(Θ(e.
</li>
<li>
در برخی کاربردها رأس‌هایی که از s قابل دسترسی نیستند را در لایۀ 
∞
درنظر می‌گیرند.
</li>
<li>
یال‌هایی که باعث اضافه شدن یک رأس می‌شوند (یا هر رأس به parent آن) درخت BFS را تشکیل می‌دهد که درخت کوتاهترین مسیر هم نامیده می‌شود.
</li>
<li>
کوتاهترین مسیر از s به هر رأس را می‌توان از درخت BFS (با دنبال کردن یال به parent) به دست آورد.
</li>
<li>
یال‌های گراف که در درخت BFS نیستند، بین لایه‌های متوالی و یا درون یک لایه هستند.
</li>
</ul>
</p>
</div>
</body>
</html>
