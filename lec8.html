<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ هفتم</title>

  	<link rel="stylesheet" href="css/all.css" type="text/css" />
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ هفتم (دوشنبه ۱۲ اسفند ۹۸)</h3><br/>
<p class="myjustify">
<ul>
<li>
مسئلۀ رزرو باند فرودگاه
</li>
<ul>
<li>
زمان داده شده را چک کنیم که در مجموعه تا k دقیقه قبل و بعد از آن فرودی نداشته باشیم
</li>
<li>
یک زمان را به مجموعۀ زمان‌های رزرو شده اضافه کنیم
</li>
<li>
یک زمان را پس از فرود از مجموعه حذف کنیم
</li>
</ul>
<li>
به صورت دقیق‌تر واسط مجموعه مرتب پویا
<li>
بررسی آرایۀ غیرمرتب و آرایۀ مرتب برای این منظور
</li>
<li>
درخت دودویی جست‌وجو
</li>
<ul>
<li>
  هر راس از زیر درخت چپ خود بزرگتر مساوی و از زیردرخت راست خود کوچکتر مساوی است<div class=""></div>
</li>
<li>
با توجه به این‌که فرض تقریباً کامل بودن درخت را نداریم، مجبور هستیم برای رأس یک کلاس درنظر بگیریم شامل کلید و اشاره‌گرهایی به والد، فرزند چپ و فرزند راست.
</li>
<li>
چگونگی
<span class="mycode" dir="ltr">find(x)</span>
</li>
<li>
مرتب‌سازی با درخت دودویی جست‌وجو - در واقع درخت دودویی جست‌وجو مجموعه را مرتب نگه می‌دارد و در (O(n می‌توان لیست مرتب را خروجی داد.
</li>
<li>
تعریف in-order (میان ترتیب)، pre-order و post-order.
</li>
<li>
درج یک عنصر جدید در درخت دودویی جست‌وجو
<span class="mycode" dir="ltr">insert(x)</span>

<pre dir="ltr" align="left">
def insert(node, k):
  if k <= node.key:
    if node.left:
      insert(node.left, k)
    else:
      node.left = new_node(key = k, parent = node, left = None, right = None)
  else:
    if node.right:
      insert(node.right, k)
    else:
      node.right = new_node(key = k, parent = node, left = None, right = None)
</pre>
</li>
<li>
 حذف یک عضو در درخت دودویی جست‌وجو و بررسی تمام حالات
<span class="mycode" dir="ltr">delete(x)</span>
<pre dir="ltr" align="left">
def find_min(node):
  if node.left:
    return find_min(node.left)
  return node
</pre>
<pre dir="ltr" align="left">
def delete_node(node):
  if node.left and node.right:
    succ = find_min(node.right)
    node.key = succ.key
    delete(succ)
  elif node.left:
      #فرزند سمت جپ جایگزین می‌شود
  elif node.right:
      #فرزند سمت راست جایگزین می‌شود
  else:
     #از والدش جدا میکنیم
</pre>
</li>
<li>
همۀ این عملیات در (O(h انجام می‌شود که h ارتفاع درخت است.
</li>
<li>
مثال درخت دودویی جست‌وجو با ارتفاع n
</li>
</ul>
<li>
موضوع دو جلسۀ بعد در مورد درخت‌های دودویی جست‌وجویی است که ارتفاع آن برابر با (O(log n بوده و به اصطلاح متوازن هستند.
</li>
<ul>
</p>
</div>
</body>
</html>
