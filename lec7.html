<html dir="rtl" lang="fa"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ ششم</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css">
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css">
	<link rel="stylesheet" href="css/syntax.css" type="text/css">
  	<link rel="stylesheet" href="css/main.css" type="text/css">
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ ششم (شنبه ۱۰ اسفند ۹۸)</h3><br>
<p class="myjustify">
</p><ul>
<li>
واسط صف اولویت (مجموعه ای، در این جا کلید همان اولویت است)
</li><li>
    واسط دنباله ای دارای اندیس و واسط مجموعه ای دارای کلید است.
</li>

<ul>
<li>
<div class="mycode" dir="ltr">
len()
</div><p>
    در آرایه‌: O(1)، در آرایه مرتب : O(1)
</p>

</li>
<li>
<div class="mycode" dir="ltr">
insert(v)
</div><p>
    در آرایه : O(1) ، در آرایه مرتب : O(1)
    </p>

</li>
<li>
<div class="mycode" dir="ltr">
find-max(), remove-max()
</div>
و یا
<div class="mycode" dir="ltr">
find-min(), remove-min()
</div>
    <p>
        در آرایه O(n)، در آرایه مرتب : O(1)
    </p>
</li>
</ul>
<li>
برخی کاربردهای صف اولویت: مرتب‌سازی و الگوریتم دایسترا (جلسه ۲۳)
</li>
<li>
مرتب‌سازی با صف اولویت و شبه‌کد آن
</li>
<p></p><pre dir="ltr" align="left">def max_pq_sort(A):
  n = len(A)
  Q = &lt; empty priority queue &gt;
  for v in A :
    Q.insert(v)
  for i in range(n) :
    A[n-1-i] = remove_max(Q) (or A[i] = rmeove_min(Q))
</pre>
<li>
داده‌ساختارهایی که تا الان گفته شدند برای صف اولویت خوب نیستند.
</li>
<li>
داده ساختار هرم دودویی
</li>
<li>
در هرم دودویی داریم :
<ul>
    <li>
        len() : O(1)
    </li>
    <li>
        insert(v) : O(logn)
    </li>
    <li>
        find/remove_max() : O(1)/O(logn)
    </li>
</ul>
</li>
<li>
در عمل از هرم فیبوناتچی استفاده می شود که درباره آن می توان گفت :
    <ul>
        <li>
            len() : O(1)
        </li>
        <li>
            insert(v) : O(1)
        </li>
        <li>
            find/remove_max() : O(1)/O(logn)
        </li>
    </ul></li>


<li>
چگونگی ذخیره این درخت (درخت دودویی) در آرایه بدون حافظه اضافه
</li>

<li>
خاصیت هرم بیشینۀ درختی
</li>
<li>
خاصیت هرم بیشینۀ رأسی و معادل بودن آن با نسخۀ درختی
</li>
<li>
چگونگی 
<span class="mycode" dir="ltr">insert</span> 
به وسیلۀ
<span class="mycode" dir="ltr">max-heapify-up()</span> 
و شبه‌کد و مثال آن
</li>





<p></p><p></p><li>
    در تمامی کدهای پایین Q یک هرم بیشینه  (درخت تقریبا کامل) است که به صورت آرایه ذخیره شده است.
</li>
<p></p>
<pre dir="ltr" align="left">def find_max(Q) :
  return Q[0]
</pre>
<p></p>
<pre dir="ltr" align="left">def insert(Q,v) :
  Q.append(v)
  max_heapify_up(Q,len(Q)-1)
</pre>

<pre dir="ltr" align="left">def max_heapify_up(Q,i):
  if i&gt;0 and Q[i]&gt;Q[parent(i)]:
    Q[i],Q[parent(i)] = Q[parent(i)],Q[i]
    max_heapify_up(Q,parent(i))
</pre>
<p></p></ul></div>


</body></html>
