<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ یازدهم</title>

  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
	<link rel="stylesheet" href="css/syntax.css" type="text/css" />
  	<link rel="stylesheet" href="css/main.css" type="text/css" />

  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ دوازدهم (شنبه ۱۶ فروردین ۹۹)</h3><br/>
<p class="myjustify">
<ul>

<li>
الگوریتم‌های مرتب‌سازی خطی
</li>
<ul>
<li>
توجه کنید این الگوریتم‌ها (و الگوریتم‌های درهم‌سازی که در جلسات بعد مطرح می‌شوند) در مدل مقایسه نیستند.
</li>
<li>
فرض بر این است که کلید عناصری که با هم مقایسه می‌کنیم عدد صحیح و نامنفی هستند (تفاوت با مدل مقایسه).
</li>
<li>
این فرض معمولاً منطقی است زیرا حتی وقتی کلیدها عدد نیستند، می‌توان عدد معادلی برای آن‌ها درنظر گرفت.
</li>
<li>
فرض می‌کنیم کلید‌ها عددی صحیح بین 0 تا k-1 هستند. (حالتی که کلید‌ها بتوانند منفی هم باشند شبیه همین حالت است)
</li>
<li>
فرض مهم: هر کلید در یک کلمه (word) جا می‌شود (یادآوری مدل ماشین دسترسی تصادفی (RAM)).
</li>
<li>
مرتب‌سازی شمارشی
</li>
<ul>
<li>
برای هر کلید ممکن بین 0 تا k-1 یک لیست در نظر می‌گیریم و هر عنصر را به لیست مربوطه اضافه می‌کنیم. در نهایت روی لیست‌ها حرکت می‌کنیم و لیست‌ها را به ترتیب خروجی می‌دهیم.
</li>
<li>
مثال و شبه‌کد (پایتون) الگوریتم
</li>
<li>
تحلیل زمانی خط به خط الگوریتم و اثبات زمان (O(n+k
</li>
<li>
وقتی قابل استفاده است که k به اندازه کافی کوچک (O(n)) باشد.
</li>
</ul>
<li>
مرتب‌سازی مبنایی
</li>
<ul>
<li>
بر خلاف مرتب‌سازی شمارشی وقتی k یک چند‌جمله‌ای از n باشد
(n<span dir="ltr"><sup>O(1)</sup></span>)
هم در زمان خطی کار می‌کند.
</li>
<li>
فرض می‌کنیم کلیدها را در مبنای b داریم.
</li>
<li>
d را تعداد ارقام k در مبنای b می‌گیریم.
</li>
<li>
مرتب‌سازی از رقم کم ارزش به سمت رقم پر ارزش
</li>
<li>
هر مرحله از مرتب‌سازی شمارشی استفاده می‌کنیم.
</li>
<li>
نکته: از یک مرتب‌سازی پایدار دلخواه می‌توان استفاده کرد.
</li>
<ul>
<li>
مرتب‌سازی پایدار: ترتیب نسبی عناصر با کلید مساوی قبل و بعد از مرتب‌سازی ثابت بماند.
</li>
</ul>
<li>
زمان اجرا برابر است با (O((n+b) d
</li>
<li>
با قرار دادن b=n زمان اجرا برابر با (O((n+n) O(1)) = O(n خواهد شد.
</li>
</ul>
<li>
سؤال باز: اگه k بزرگ باشد هنوز می‌توان عناصر را در زمان خطی مرتب کرد.
</li>
<li>
زمان بهترین الگوریتم موجود (O(n √<span style="text-decoration:overline">log log n</span>
 با احتمال بالا است.
</li>
</ul>
</p>
</div>
</body>
</html>
