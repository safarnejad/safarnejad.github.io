<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ نوزدهم</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
	<link rel="stylesheet" href="css/syntax.css" type="text/css" />
  	<link rel="stylesheet" href="css/main.css" type="text/css" />
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ نوزدهم (دوشنبه ۴ آذر ۹۸)</h3><br/>
<p class="myjustify">
<ul>
<li>
ایده: تغییر یک داده‌ساختار آماده و نگه‌داری اطلاعات اضافه در آن
</li>
<li>
داده‌ساختارهای افزودۀ معمول
</li>
<ul>
<li>
هدف: ذخیره تابع
(f(v
از زیردرخت v در رأس v
</li>
<li>
مقدار تابع برای v باید بتواند از روی مقدار تابع فرزندان v محاسبه شود.
</li>
<li>
هر تغییر در داده‌ساختار 
مثل درج یک عنصر، حذف یک عنصر و یا تغییر مقدار یک عنصر
فقط روی مقدار تابع مسیر آن رأس به ریشه تأثیر می‌گذارد. بنابر خاصیت بالا زمان به‌روزرسانی این مقادیر 
(Θ(h
است که h  ارتفاع درخت است.
</li>
<li>
درخت‌های ای‌وی‌ال برای این کار مناسب هستند.
</li>
<li>
توابع معمول: جمع، ضرب، کمینه، بیشینه، xor و ...
</li>
</ul>
<li>
یادآوری درخت مرتبه آماری (order-statistic)
</li>
<ul>
<li>
واسط: درج، حذف، عنصر بعدی، مرتبه یک عنصر داده شده، انتخاب عنصر با مرتبۀ خاص
</li>
<li>
ایده: نگه‌داری تعداد عناصر زیردرخت در هر رأس درخت ای‌وی‌ال
</li>
<li>
به‌روزرسانی و جست‌وجو در زمان 
(Θ(log n
 انجام می‌شود.
</li>
<li>
کد مرتبۀ یک عنصر داده شده و کد انتخاب عنصر با مرتبۀ خاص و مثال از هر کدام
</li>
</ul>
<li>
درخت پاره‌خطی
</li>
<ul>
<li>
با فرض این که کلیدها اعداد صحیح از ۱ تا 
m
هستند، یک درخت دودویی تقریباً کامل روی آن‌ها ایجاد می‌کنیم و مثل قبل تابع f را برای هر رأس و زیردرخت آن نگه‌داری می‌کنیم.
</li>
<li>
در مقایسه با درخت ای‌وی‌ال افزوده، ساختار درخت پاره‌خطی تغییر نمی‌کند و پیاده‌سازی آن آسان‌تر است.
</li>
<li>
حافظه و زمان اجرای آن 
(Θ(log m
 است و نه 
(Θ(log n.
</li>
</ul>
<li>
وقتی به جای یک عنصر بخواهیم همۀ عناصر یک بازه را تغییر دهیم:
</li>
<ul>
<li>
به طور مثال همۀ عناصر یک بازه به یک مقدار مشخص تغییر کنند یا همه به یک میزان اضافه شوند.
</li>
<li>
برای این که زمان اجرا زیاد نشود از انتشار تنبل گونه! (lazy propagation) استفاده می‌کنیم.
</li>
<li>
هم در درخت ای‌وی‌ال افزوده و هم در درخت پاره‌خطی قابل استفاده است.
</li>
<li>
ایده: تا وقتی به یک رأس نرفته‌ایم، به مقدار تابع آن نیاز نداریم.
</li>
<li>
روی یک رأس یک علامت (flag) قرار می‌دهیم که عناصر این زیردرخت به روز نیستند.
</li>
<li>
در زمان جست‌وجو اگر به چنین رأسی برخورد کردیم، فرزندان آن را به روز می‌کنیم و روی آن‌ها علامت قرار می‌دهیم.
</li>
<li>
هر به‌روزرسانی به حداکثر
4log<sub>2</sub> n
خانه دسترسی خواهد داشت.
</li>
<li>
زمان به‌روزرسانی یک بازه و جست‌جو هر دو (از دید مجانبی) مانند قبل خواهد بود.
</li>
</ul>
</ul>
<ul>
<li>
درخت فنویک
</li>
<ul>
<li>
اگر بخواهیم جمع را در درخت پاره‌خطی نگه داریم، می‌توانیم مقدار تابع را فقط برای نصف رأس‌ها ذخیره کنیم و به جای 2n-1 رأس، در n رأس اطلاعات را ذخیره کنیم.
</li>
<li>
درخت فنویک این کار را به صورت هوشمندانه انجام می‌دهد و اطلاعات جمعی را بدون هیچ‌گونه حافظۀ اضافه نگه‌داری می‌کند.
</li>
<li>
توابعی مثل جمع، ضرب و xor در این داده‌ساختار پشتیبانی می‌شوند ولی کمینه و بیشینه پشتیبانی نمی‌شوند.
</li>
<li>
تصویر ساختار درختی آن پیچیده است ولی کد بسیار کوتاهی دارد.
</li>
<li>
کد پایتون درخت فنویک (با فرض اندیس‌گذاری آرایه از صفر)
<pre dir="ltr" align="left">
def sum(index):
  result = 0
  while idx:
    result += array[index]
    index -= index & -index
  return result
</pre>
<pre dir="ltr" align="left">
def update(index, add):
  while idx < len(self.array):
    array[index] += add
    index += index & -index
</pre>
</li>
<li>
مثال اجرای 
(sum(13
و
(add(5,2
روی یک درخت فنویک ۱۴ رأسی.
</li>
</ul>
<hr/>
</p>
</div>
</body>
</html>
