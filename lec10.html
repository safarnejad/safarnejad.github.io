<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ نهم</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
	<link rel="stylesheet" href="css/syntax.css" type="text/css" />
  	<link rel="stylesheet" href="css/main.css" type="text/css" />
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ نهم (دوشنبه ۱۹ اسفند ۹۸)</h3><br/>
<p class="myjustify">
<ul>
<li>
درخت‌های جست‌وجوی متوازن
</li>
<ul>
<li>
درخت ای‌وی‌ال (۱۹۶۲) اولین درخت جست‌وجوی متوازن (که توضیح داده شد)
</li>
<li>
درخت ۲-۳، درخت ۲-۳-۴ و درخت بی (۱۹۷۲) درخت‌های جست‌وجوی متوازن هستند که دودویی نیستند و تعداد فرزندان هر رأس می‌تواند بیشتر باشد. در درخت ۲-۳ هر رأس دو فرزند یا سه فرزند دارد. در درخت ۲-۳-۴ هر رأس دو، سه و یا چهار فرزند دارد. در درخت بی تعداد فرزندان بین k تا 2k-1 برای یک پارامتر ثابت k است. درخت بی برای دسترسی کمتر به حافظۀ اصلی طراحی شده است.
</li>
<li>
درخت [BB[α 
(سال ۱۹۷۳)
که میزان توازن آن به پارامتر α بستگی دارد.
</li>
<li>
درخت قرمز-سیاه که موضوع این جلسه است
</li>
<li>
درخت اسپلِی (۱۹۸۵) که پس از هر find رأس پیدا شده را با دوران به ریشه می‌آورد تا در صورت دسترسی بعدی به سرعت پیدا شود. 
</li>
<li>
لیست پرشی (skip list) (سال ۱۹۸۹) که داده ساختاری بین درخت و لیست است.
</li>
<li>
درخت scapegoat (سال ۱۹۹۳) که حافظۀ اضافه ندارد و به صورت تصادفی قسمتی از درخت را از نو به صورت متوازن بازسازی می‌کند.
</li>
<li>
تریپ (treap)(۱۹۹۶) ترکیب درخت دودویی جست‌و‌جو (تری) و هرم (هیپ)
</li>
</ul>
<li>
تعریف و خواص درخت قرمز-سیاه:
</li>
<ul>
<li>
۱. رنگ هر رأس یا قرمز است و یا سیاه.
</li>
<li>
۲.رئوس nil بجای فرزندانی که وجود ندارند قرار میگیرند و رنگ سیاه دارند.
</li>
<li>
۳. اگر یک رأس قرمز باشد، والد آن در صورت وجود سیاه است.
</li>
<li>
۴. هر مسیر دلخواه از ریشه به هر برگ دارای تعداد یکسانی رأس سیاه است که ارتفاعِ سیاه یا سیاه ارتفاع نامیده می‌شود (رئوس nil در ارتفاع به حساب نمی‌آیند).
</li>
</ul>
<li>
مثالی از درخت قرمز-سیاه و بررسی خواص آن
</li>
<li>
اثبات متوازن بودن درخت قرمز-سیاه:
</li>
<ul>
<li>
۱. رئوس قرمز را با والد خود ادغام می‌کنیم و یک درخت ۲-۳-۴ به وجود می‌آید.
</li>
<li>
۲. با توجه به این که کاملاً متوازن بودن این درخت و این که هر رأس حداقل دو فرزند دارد، می‌توان گفت
<span dir="ltr">N<sub>h</sub>≥2<sub>h</sub>-1</span>
و بنابراین 
<span dir="ltr">h≤2 log<sub>2</sub>(n+1)</span>.
</li>
</ul>
<li>
درج در درخت قرمز-سیاه:
</li>
<ul>
<li>
مشابه درخت ای‌وی‌ال ابتدا درج را به صورت عادی انجام می‌دهیم و سپس از پایین به بالا درخت را تصحیح می‌کنیم.
</li>
<li>
در تصحیح همیشه روی یک رأس قرمز هستیم که والد آن نیز قرمز است (با بررسی شرایط درخت قرمز)
</li>
<li>
۱. اگر عموی آن نیز قرمز باشد، کافی است رنگ پدر و عمو را سیاه کنیم و رنگ پدربزرگ را قرمز کنیم و از پدربزرگ کار را به صورت بازگشتی ادامه دهیم.
</li>
<li>
۲. اگر عمو سیاه بود نیاز به دوران داریم. اگر مسیر خود-پدر-پدربزرگ زیگزاگی بود نیاز به دو دوران داریم وگرنه نیاز به یک دوران. این دوران‌ها کاملاً مشابه درخت ای‌وی‌ال است. علاوه بر دوران نیاز به تغییر رنگ رئوس نیز داریم.
</li>
<li>
مثالی از یک درج در درخت قرمز-سیاه
</li>
</ul>
<li>
درخت قرمز سیاه در مقایسه با درخت ای‌وی‌ال ارتفاع بیشتری ممکن است داشته باشد اما حافظۀ اضافه کمتری استفاده می‌کند.
</li>
<li>
  ارتفاع کم برای جست‌و‌جو بهتر اما برای درج سختتر است.
</li>
<li>
حذف درخت قرمز-سیاه مشابه درج آن نیست و نیاز به درنظر گرفتن چهار حالت دیگر دارد.
</li>
<li>
مرتب‌سازی قرمز-سیاه نیز به صورت مشابه قابل تعریف است.
</li>
</p>
</div>
</body>
</html>
