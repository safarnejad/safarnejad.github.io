<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ بیست و ششم</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
	<link rel="stylesheet" href="css/syntax.css" type="text/css" />
  	<link rel="stylesheet" href="css/main.css" type="text/css" />
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ بیست و ششم (شنبه ۷ دی ۹۸)</h3><br/>
<p class="myjustify">
<ul>
<li>
یادآوری تعریف کوتاهترین مسیر بین دو رأس و مسئلۀ کوتاهترین مسیر از مبدأ مشخص به بقیه رأس‌ها (SSSP)
</li>
<li>
چارچوب الگوریتم مبتنی بر relax کردن
</li>
<li>
یادآوری الگوریتم کوتاهترین مسیر در DAG
</li>
<li>
وقتی گراف دارای دور منفی باشد، مسئلۀ کوتاهترین مسیر عملاً قابل حل نیست. در این صورت می‌توانیم
</li>
<ul>
<li>
راه اول: فقط وجود دور منفی را گزارش می‌کنیم. 
</li>
<li>
راه دوم: تمام رئوسی که به خاطر دور منفی، طول کوتاهترین مسیر از s (مبدأ) به آن‌ها 
∞-
است را گزارش کنیم و برای بقیه کوتاهترین مسیر را پیدا کنیم.
</li>
<li>
راه سوم: یک دور منفی را پیدا کنیم.
</li>
</ul>
<li>
الگوریتم بلمن-فورد همان چارچوب مبتنی بر relax کردن است که در n-1 راند، یال‌ها به ترتیب دلخواه relax می‌شوند.
</li>
<li>
الگوریتم بلمن-فورد در حالتی که دور منفی وجود ندارد کوتاهرین مسیر از s به بقیه را پیدا می‌کند و در صورت وجود دور منفی می‌تواند با اندکی تغییر هر کدام از راه‌های بالا را انجام دهد.
</li>
<li>
کد بلمن-فورد
<pre dir="ltr" align="left">
Bellman-Ford:
  initialize parent and d arrays
  for round in range(n-1):
    for edge (u,v) in G:
      relax(u,v)
  somehow handle negative weight cycles
  return parent, d
</pre>
</li>
<li>
اجرای الگوریتم بلمن فورد روی یک گراف ۶ رأسی
</li>
<li>
اثبات درستی الگوریتم بلمن-فورد
</li>
<ul>
<li>
استقرای قوی روی این که پس از راند iاُم، [d[v
کمتر مساوی طول کوتاهترین مسیر از s به v با حداکثر i یال است.
</li>
</ul>
<li>
زمان اجرای الگوریتم
(O(ne
</li>
<li>
پیاده‌سازی راه‌های برخورد با دور منفی:
</li>
<ul>
<li>
۱. گزارش وجود دور منفی: کافی است relax کردن‌ها را یک راند دیگر انجام دهیم و اگر d مربوط به رأسی به‌روز شد به معنی وجود دور منفی است.
</li>
<li>
کد اضافه شده در این حالت:
<pre dir="ltr" align="left">
# 1st approach: check for negative weight cycles
for edge (u,v) in G:
  if d[v] > d[u] + w(u,v):  # This edge can be relaxed
    raise ValueError("There’s a negative cycle reachable from s!")
</pre>
</li>
<li>
در الگوریتم بالا، دور منفی اگر از s قابل دسترس بود گزارش می‌شود. برای پیدا کردن دور منفی در گراف (وقتی به کوتاهترین مسیرها نیازی نداریم)، می‌توان d همۀ رأس‌ها را در ابتدای الگوریتم صفر قرار داد.
</li>
<li>
۲. گزارش رأس‌هایی که کوتاهترین مسیر از s به آن‌ها
∞-
است: الگوریتم را n راند دیگر ادامه می‌دهیم و رئوسی که d آن‌ها در یکی از این راندهای اضافه به‌روز می‌شوند را به عنوان رأسی‌هایی که dشان
∞-
است گزارش می‌کنیم. d بقیه رأس‌ها نیز صحیح است.
</li>
<li>
۳. پیدا کردن یک دور منفی: به روز رسانی‌ها را یک راند بیشتر انجام می‌دهیم. سپس  با پیمایش parent یکی از رأس‌هایی که در مرحلۀ آخر d آن به‌روز شده، یک دور منفی پیدا می‌کنیم. توجه کنید رأسی که d آن به‌روز شده است ممکن است خودش در دور نباشد.
</li>
</ul>
<li>
یال و دور منفی در بسیاری از گراف‌ها مثل گراف نقشه وجود ندارد. برای همین مثال کاربردی بودن الگوریتم بلمن-فورد ممکن است به ذهن نرسد. برای این کار مسئلۀ تبدیل ارزها و دور معیوب مطرح شد.
</li>
<li>
اگر یک دستگاه معادلات داشته باشیم که شامل m معادله به صورت
<span dir="ltr">x<sub>j</sub> - x<sub>i</sub> ≤ b<sub>k</sub></span>
باشد، می‌توان این دستگاه را با الگوریتم بلمن-فورد حل کرد.
</li>
<ul>
<li>
برای این کار برای هر 
x<sub>i</sub>
یک رأس قرار می‌دهیم و برای هر معادله یک یال جهت‌دار از 
x<sub>i</sub>
به
x<sub>j</sub>
با وزن
b<sub>k</sub>
قرار می‌دهیم.
</li>
<li>
در ابتدای الگوریتم d همه را صفر قرار می‌دهیم و الگوریتم بلمن-فورد را اجرا می‌کنیم.
</li>
<li>
اگر دور منفی وجود نداشته باشد الگوریتم یک جواب معتبر پیدا می‌کند و در صورتی که دور منفی وجود داشته باشد، دستگاه قابل حل نیست.
</li>
</ul>
</ul>
</p>
</div>
</body>
</html>
