<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ پانزدهم</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
	<link rel="stylesheet" href="css/syntax.css" type="text/css" />
  	<link rel="stylesheet" href="css/main.css" type="text/css" />
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ پانزدهم (دوشنبه ۲۵ فروردین ۹۹)</h3><br/>
<p class="myjustify">
<ul>
<li>
آخرین جلسه با موضوع درهم‌سازی
</li>
<li>
درهم سازی کامل (JACM سال ۱۹۸۴): یک راه دیگر برای حل مشکل برخورد
</li>
<ul>
<li>
هر جست‌وجو تنها به دو بار محاسبۀ تابع درهم‌سازی نیاز دارد.
</li>
<li>
درهم‌سازی اصلی با m=n انجام می‌شود. به جای زنجیره از یک جدول درهم‌سازی دیگر استفاده می‌کنیم.
</li>
<li>
اگر k کلید به یک خانه از جدول اولیه اختصاص پیدا کرده باشند، جدول دیگری با اندازۀ
k<sup>2</sup>
می‌گیریم. به احتمال کمتر از 1/2 در این جدول برخورد رخ می‌دهد زیرا تعداد کل برخورد‌های ممکن k(k-1)/2 است و احتمال هر برخورد
<span dir="ltr">1/k<sup>2</sup></span>
است.
</li>
<li>
پس [تعداد برخورد]𝔼 کمتر از ۱/۲ است و بنابراین احتمال برخورد نیز کمتر از ۱/۲ است. اگر برخورد رخ داد می‌توان جدول را دوباره با تابع درهم‌سازی جدید ساخت.
</li>
<li>
ایدۀ این روش از پارادوکس روز تولد می‌آید: احتمال این که روز تولد دو نفر در یک جمع ۲۰ نفره تصادفی یکسان باشد حدود ۱/۲ می‌شود (چون تعداد افراد بیش از جذر ۳۶۵ است).
</li>
<li>
نکتۀ قابل توجه این روش این است که حافظۀ مورد‌انتظار آن (O(n است.
</li>
<li>
به صورت معمول از این روش وقتی استفاده می‌شود که از ابتدا همۀ اشیاء داده شده باشند، ولی روش درج و حذف نیز برای آن پیشنهاد شده است.
</li>
</ul>

<li>
درهم‌سازی کوکو: دوباره یک روش دیگر برای حل مشکل برخورد
</li>
<ul>
<li>
کوکو (مثل پرندۀ ساعت کوکی) پرنده‌ای است که خانۀ یک پرندۀ دیگر را اشغال می‌کند و تخم‌های آن را بیرون می‌ریزد. درهم‌سازی کوکو نیز برای رفع مشکل برخورد از این روش استفاده می‌کند.
</li>
<li>
جست‌وجو در این روش به یک یا دو محاسبۀ تابع درهم‌سازی نیاز دارد.
</li>
<li>
در این روش دو جدول (T<sub>1</sub> و T<sub>2</sub>) با اندازۀ m=2n داریم.
</li>
<li>
هر جدول یک تابع درهم‌سازی مخصوص خود (h<sub>1</sub> و h<sub>2</sub>) دارد.
</li>
<li>
برای جست‌وجوی x کافی است ابتدا خانۀ
<span dir="ltr">T<sub>1</sub>[h<sub>1</sub>(x)]</span>
و سپس خانۀ
<span dir="ltr">T<sub>2</sub>[h<sub>2</sub>(x)]</span>
را بررسی کنیم.
اگر x در هیچ کدام از این دو خانه نبود می‌دانیم درج نشده است.
</li>
<li>
برای درج همین دو خانه را به ترتیب بررسی می‌کنیم و اگر یکی از آن‌ها خالی بود x را در آن‌جا درج می‌کنیم. در صورتی که هر دو خانه پر بودند، به این صورت عمل می‌کنیم:
</li>
<ul>
<li>
x را در 
<span dir="ltr">T<sub>1</sub>[h<sub>1</sub>(x)]</span>
درج می‌کنیم و شیء قبلی که در این خانه بود را بیرون می‌اندازیم و به جدول 
<span dir="ltr">T<sub>2</sub></span>
منتقل می‌کنیم. اگر این انتقال به یک خانۀ خالی بود که کار تمام است، وگرنه کسی که قبلاً در این خانه بوده را بیرون می‌اندازیم و به همین صورت جلو می‌رویم.
</li>
<li>
اگر این روند طولانی شد (حداقل log n مرحله طول کشید)، جدول را از نو می‌سازیم. توجه کنید حتی ممکن است در دور بی‌نهایت افتاده باشیم.
</li>
<li>
احتمال از نو ساختن جدول بسیار کم است و به همین خاطر زمان درج به صورت سرشکن 
<span dir="ltr">O(1)</span>
است (با فرض استفاده از خانوادۀ توابع درهم‌سازی <span dir="ltr">Θ(log n)</span>-تایی مستقل).
</li>
</ul>
</ul>

<li>
فیلتر بلوم
</li>
<ul>
<li>
یک روش بسیار پرکاربرد برای جست‌وجوی احتمالی در یک مجموعه: اگر بگوییم x عضو مجموعه نیست، قطعاً عضو مجموعه نیست و اگر بگوییم x عضو مجموعه هست، به احتمال زیاد (<span dir="ltr">1-p</span>) عضو مجموعه است. 
</li>
<li>
کاربردهای فراوان:
</li>
<ul>
<li>
آکامای یک شرکت معروف در زمینۀ شبکۀ تحویل محتوا (CDN) است که فایل‌های ایستا را در سرورهای مختلف ذخیره می‌کند تا دسترسی به آن‌ها از هر مکانی به سرعت انجام شود. این شرکت با فایل‌هایی روبه‌رو شد (one-hit-wonders) که فقط یک بار فراخوانده می‌شدند و یک سوم از حجم کل سرورها را به خود اختصاص می‌دادند. این شرکت با استفاده از فیلتر بلوم این فایل‌ها را از سرورها حذف کرد و به میزان زیادی در حافظۀ سرورها صرفه‌جویی کرد.
</li>
<li>
مرورگر کروم آدرس‌های بد را ابتدا به صورت محلی با فیلتر بلوم بررسی می‌کند و در صورتی که به بد بودن آن مشکوک شد، آن آدرس را به سرورهای مخصوص خود برای بررسی ارسال می‌کند.
</li>
<li>
در بیت‌کوین برای سنکرون کردن کیف پول و در اِتِریوم برای پیدا کردن لاگ از فیلتر بلوم استفاده می‌شود.
</li>
</ul>
<li>
در فیلتر بلوم یک جدول درهم‌سازی دودویی (صفر و یک) دارد و k تابع درهم‌سازی وجود دارد.
</li>
<li>
در درج یک شیء، مقدار k تابع درهم‌سازی آن محاسبه شده و k خانۀ مربوط به آن ۱ می‌شوند.
</li>
<li>
در جست‌وجوی یک شیء، مقدار k تابع آن محاسبه شد و اگر تمام آن‌ها مقدار ۱ داشتند می‌گوییم در مجموعه (به احتمال زیاد) وجود دارد و اگر حداقل یکی از خانه‌ها صفر بود می‌گوییم در مجموعه وجود ندارد.
</li>
<li>
توجه کنید امکان حذف شیء از مجموعه در فیلتر بلوم وجود ندارد.
</li>
<li>
احتمال خطا از رابطۀ
<span dir="ltr">p = (1-e<sup>-kn/m</sup>)<sup>k</sup></span>
به دست می‌آید.
</li>
<li>
با داشتن مقدار n (تعداد اشیاء) و p  (حداکثر خطای مورد نظر) می‌توان m (اندازۀ جدول بهینه) و k (تعداد توابع درهم‌سازی) را به صورت زیر به‌دست آورد:
</li>
<ul>
<li>
<span dir="ltr">m = -n.ln(p) / (ln(2)<sup>2</sup>)</span>
</li>
<li>
<span dir="ltr">k = (m/n)ln(2)</span>
</li>
</ul>
<li>
به طور مثال برای یک میلیون شیء و خطای یک درصد به جدولی به اندازۀ m=۹٬۵۹۲٬۹۵۵
<span dir="rtl"> (معادل ۱.۲ مگابایت) </span>
 و ۷ تابع درهم‌سازی نیاز داریم.
</li>
<li>
فیلتر بلوم هنوز هم موضوع مهمی در پژوهش است و بهبود مختلفی روی آن پیشنهاد شده است.
</li>
</ul>

</p>
</div>
</body>
</html>
