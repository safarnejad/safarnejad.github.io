<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ چهاردهم</title>

  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
	<link rel="stylesheet" href="css/syntax.css" type="text/css" />
  	<link rel="stylesheet" href="css/main.css" type="text/css" />

  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ چهاردهم (شنبه ۲۳ فروردین ۹۹)</h3><br/>
<p class="myjustify">
<ul>

<li>
توابع درهم‌سازی
</li>
<ul>
<li>
روش تقسیم:
<span dir="ltr">h(k) = k mod m</span>
</li>
<ul>
<li>
وقتی  در عمل خوب است که m عدد اول باشد و نزدیک به توان‌های ۲ و ۱۰ نباشد.
</li>
<li>
پیدا کردن عدد اول در هر بار تغییر اندازۀ جدول و محاسبۀ باقی‌مانده زمان‌بر است.
</li>
</ul>
<li>
روش ضرب:
<span dir="ltr">h(k) = [(a.k) mod 2<sup>w</sup>] ≫ (w-r)</span>
</li>
<ul>
<li>
این تعریف با روش ضرب کتاب کمی متفاوت است.
</li>
<li>
در این‌جا a تصادفی است و تعداد رقم‌های k برابر با w است. همچنین m=2<sup>r</sup> است.
</li>
<li>
در عمل در صورتی خوب است که a فرد باشد و
2<sup>w-1</sup> < a < 2<sup>w</sup>
و a خیلی نزدیک به 2<sup>w-1</sup> و 2<sup>w</sup> نباشد.
</li>
<li>
ضرب و استخراج بیت‌ها سریع‌تر از تقسیم است.
</li>
</ul>
<li>
درهم‌سازی سراسری
</li>
<ul>
<li>
یک خانواده از توابع درهم‌سازی داریم که در ابتدای الگوریتم یکی از آن‌ها را به صورت تصادفی انتخاب می‌کنیم و در ادامه از آن استفاده می‌کنیم.
</li>
<li>
به طور مثال
<span dir="ltr">h(k) = [(ak+b) mod p] mod m</span>
</li>
<li>
a و b اعداد تصادفی در مجموعۀ
<span dir="ltr">{0, 1, ..., p-1}</span>
هستند و p یک عدد اول بزرگ (بزرگ‌تر از اندازۀ 𝒰) است.
</li>
<li>
برای دو کلید دلخواه k<sub>1</sub> و k<sub>2</sub> که k<sub>1</sub>≠k<sub>2</sub> ثابت می‌شود:
</li>
<ul>
<li>
<span dir="ltr">Pr<sub>a,b</sub>{h(k<sub>1</sub>)=h(k<sub>2</sub>)} = 1/m</span>
</li>
<li>
توجه کنید که احتمال بر روی انتخاب a  و b تصادفی هست.
</li>
</ul>
<li>
با استفاده از این موضوع می‌توان ثابت کرد که میانگین طول زنجیره برابر α است.
</li>
</ul>
</ul>
<li>
آدرس‌دهی باز
</li>
<ul>
<li>
به جای استفاده از لیست پیوندی (زنجیره)، کل اشیاء را در خود جدول ذخیره می‌کنیم.
</li>
<li>
اندازۀ جدول را m≥2n می‌گیریم.
</li>
<li>
دنبالۀ وارسی شیء x به صورت زیر تعریف می‌شود:
</li>
<ul>
<li>
<span dir="ltr">h(x,0), h(x,1), h(x,2), ..., h(x,m-1)</span>
</li>
</ul>
<li>
برای درج شیء x خانه‌های جدول را به ترتیب دنبالۀ وارسی نگاه می‌کنیم و در اولین خانۀ خالی آن را درج می‌کنیم.
</li>
<li>
برای جست‌وجوی شیء x خانه‌های جدول را به ترتیب دنبالۀ وارسی نگاه می‌کنیم. یا x را پیدا می‌کنیم و یا به یک خانۀ خالی برخورد می‌کنیم که در این صورت متوجه می‌شویم x در جدول قرار ندارد.
</li>
<li>
حذف نیاز به دقت بیشتری دارد. اگر پس از حذف یک شیء خانۀ مربوط به آن را خالی کنیم، جست‌وجوهای بعدی ممکن است درست کار نکنند. برای این کار پس از حذف، در خانه می‌نویسیم «حذف شده». خانه‌های حذف شده در جست‌وجو مثل یک خانۀ پر درنظر گرفته می‌شوند و در درج مثل یک خانۀ خالی. (البته قبل از درج لازم است یک بار جست‌وجو انجام دهیم وگرنه ممکن است یک کلید را دوبار در جدول داشته باشیم).
</li>
<li>
اگر تعداد خانه‌های «حذف شده» به ۱۰ درصد رسیدند، جدول را دوباره می‌سازیم. با این کار هزینه سرشکن هنوز (O(1 می‌ماند.
</li>
</ul>
<li>
روش‌های وارسی
</li>
<ul>
<li>
روش وارسی خطی:
<span>h(x,i)=(h'(x) + i) mod m
</li>
<ul>
<li>
مشابه پارک کردن ماشین
</li>
<li>
مشکل خوشه‌ها: خوشه از خانه‌های متوالی جدول که پر هستند تشکیل شده است. هر چه خوشه بزرگ‌تر باشد، احتمال رشد آن بیشتر است. خوشه‌های به اندازۀ
(Θ(log n
به وجود می‌آیند که زمان جست‌وجو و یا درج را زیاد می‌کنند.
</li>
</ul>
<li>
روش وارسی درجۀ دو:
<span>h(x,i)=(h'(x) + ai<sup>2</sup>+bi) mod m
</li>
<ul>
<li>
ثابت شده است وارسی درجۀ ۵ خوب کار می‌کند و وارسی‌های درجۀ ۴‌ای وجود دارد که بد کار کنند.
</li>
</ul>
<li>
درهم‌سازی دوگانه:
<span>h(x,i)=(h<sub>1</sub>(x) + i.h<sub>2</sub>(x)) mod m
</li>
<ul>
<li>
باید (h<sub>2</sub>(x و m نسبت به هم اول باشند.
</li>
<li>
یک راه این است که  m یک عدد اول باشد و مقدار (h<sub>2</sub>(x بین 1 و m-1 باشد.
</li>
<li>
یک راه بهتر این است که m  توانی از ۲ باشد و (h<sub>2</sub>(x فرد باشد.
</li>
</ul>
</ul>
<li>
فرض درهم‌سازی یکنواخت
</li>
<ul>
<li>
با فرض درهم‌سازی یکنواخت ساده که در جلسه قبل گفته شد اشتباه نشود.
</li>
<li>
دنبالۀ وارسی هر کلید، یکی از !m جایگشت ممکن را به صورت تصادفی و مستقل تولید می‌کند.
</li>
<li>
به صورت کامل درست نیست، ولی درهم‌سازی دوگانه تا حد خوبی به این فرض نزدیک است.
</li>
<li>
تحلیل زمان آدرس‌دهی باز با فرض درهم‌سازی یکنواخت (Uniform Hashing Assumption)
</li>
<ul>
<li>
در اولین مرحله n خانه از جدول پر است، پس m-n خانه از m خانۀ جدول خالی است. بنابراین احتمال این که در اولین مرحله بتوانیم درج را انجام دهیم برابر است با
<span dir="ltr">(m-n)/m</span>
است که این مقدار را p می‌نامیم.
</li>
<li>
در مرحلۀ iاُم هنوز m-n خانه از جدول (با احتساب حذف خانه‌های بررسی شده تا کنون) خالی است و در کل m-i+1 خانه بررسی نشده وجود دارد. بنابراین احتمال این که در این مرحله بتوانیم درج را انجام دهیم برابر است با
<span dir="ltr">(m-n)/(m-i+1)≥p</span>.
</li>
<li>
میانگین تعداد مراحل برای موفقیت در درج (با قوانین سادۀ احتمال) برابر است با:
<br/>
<span dir="ltr">𝔼[#trials] = 1/p = 1/(1-α)</span>
که α ضریب بارگذاری است.
</li>
</ul>
</p>
</div>
</body>
</html>
