<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ دهم</title>

  <link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  <link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
  <link rel="stylesheet" href="css/syntax.css" type="text/css" />
  <link rel="stylesheet" href="css/main.css" type="text/css" />

  <script src="js/jquery-1.11.0.min.js"></script>
  <script src="js/bootstrap.min.js"></script>
  <style>
    table {

      border-collapse: collapse;
      width: 100%;
    }

    table:nth-child(1) {
      background-color: #dddddd;
    }

    td,
    th {
      border: 1px solid #dddddd;
      text-align: center;
      padding: 8px;
    }

    tr:nth-child(1) {
      background-color: #dddddd;
    }
  </style>
</head>

<body>
  <div id="page" class="container mynarrow">
    <h3 class="nomargintop">جلسۀ دهم (شنبه ۲۴ اسفند ۹۸)</h3><br />
    <p class="myjustify">
	<ul>
      <li>
        مرتب‌سازی سریع (سال ۱۹۶۲)
      </li>
      <ul>
        <li>
          حافظه: O(1) + اجرای بازگشتی با عمق log(n)
        <li>
          حافظه اضافه آن (Θ(1 است و از این جنبه بهتر است مرتب سازی ادغامی است.
        </li>
        <li>
          زمان اجرای مرتب‌سازی سریع در عمل حدود دو برابر سریع‌تر از مرتب‌سازی ادغامی است.
        </li>
        <li>
          مرتب‌سازی مورد استفاده در زبان سی‌پلاس‌پلاس و زبان جاوا (برای مرتب کردن اعداد و نه کلاس‌ها)
        </li>
        <li>
          مرتب‌سازی سریع بر اساس تقسیم و حل است ولی قسمت عمدۀ کار آن در مرحلۀ تقسیم انجام می‌شود (در مقایسه با مرتب‌سازی
          ادغامی که عمدۀ کار آن در مرحلۀ ادغام انجام می‌شد).
        </li>
      </ul>
	  <br/>
      <table style="width:100%">
        <tr>
          <th>تقسیم و حل</th>
          <th>ادغامی</th>
          <th>سریع</th>

        </tr>
        <tr>
          <td bgcolor="#dddddd">تقسیم</td>
          <td>ساده</td>
          <td>+</td>
        </tr>
        <tr>
          <td bgcolor="#dddddd">حل</td>
          <td>بدیهی</td>
          <td>بدیهی</td>
        </tr>
        <tr>
          <td bgcolor="#dddddd">ادغام</td>
          <td>+</td>
          <td>نیاز نیست</td>
        </tr>
      </table>
      <li>
        مراحل الگوریتم:
      </li>
      <ul>
        <li>
          ورودی: یک آرایه [A[0,...,n-1 به طول n
        </li>
        <li>
          خروجی: آرایۀ مرتب‌شدۀ A
        </li>
        <li>
          مرحلۀ صفر: انتخاب یک عنصر لولا به نام x از A
        </li>
        <li>
          مرحلۀ اول (تقسیم): تقسیم A به سه قسمت
          L (عناصر کوچک‌تر از E ،(x
          (عناصر برابر با x) و
          G (عناصر بزرگ‌تر از x).
        </li>
        <li>
          مرحلۀ دوم (حل): مرتب‌سازی قسمت‌های L و G به صورت بازگشتی.
        </li>
        <li>
          مرحلۀ سوم (ادغام): ادغام نیاز نیست.
        </li>
        <li>
          مسئلۀ اصلی در مرتب‌سازی سریع این است که چطور لولا را انتخاب کنیم تا اندازۀ قسمت‌های L و G متوازن باشد. (اگر
          نامتوازن باشند زمان اجرای الگوریتم (Θ(n<sup>2</sup> می‌شود)
        </li>
      </ul>
      <li>
        انواع مرتب‌سازی سریع
      </li>
      <ul>
        <li>
          ۱. مرتب‌سازی سریع پایه‌ای: عنصر اول یا آخر آرایه را به عنوان عنصر لولا درنظر می‌گیرد. در بدترین حالت (وقتی
          آرایۀ صعودی یا نزولی باشد) زمان اجرای آن (Θ(n<sup>2</sup> است.
        </li>
        <ul>
          <li>
            یک راه این است که عنصر وسط را به عنوان لولا انتخاب کنیم. در این حالت مشکل آرایۀ صعودی و نزولی حل می‌شود اما
            حالت‌های بد دیگری هنوز وجود دارند.
          </li>
          <li>
            راه‌حل بهتر بهم ریختن تصادفی (shuffle) ‌ورودی قبل از اجرای الگوریتم است.
          </li>
        </ul>
        <li>
          ۲. مرتب‌سازی سریع با انتخاب هوشمندانۀ لولا: با الگوریتم خطی میانه را پیدا می‌کنیم و از آن به عنوان لولا
          استفاده می‌کنیم.
        </li>
        <ul>
          <li>
            زمان اجرای این نوع مرتب‌سازی سریع (در بدترین حالت):
            (T(n) = Θ(n) + 2T(n/2) = Θ(n log n
          </li>
          <li>
            متأسفانه ضریب این روش زیاد است و به مرتب‌سازی ادغامی می‌بازد! (زمان اجرای آن حدود دو برابر مرتب‌سازی ادغامی
            است)
          </li>
          <li>
            الگوریتم میانۀ میانه‌ها (برای پیدا کردن میانه به عنوان عنصر لولا)
          </li>
          <ul>
            <li>
              ورودی: یک مجموعۀ S و یک عدد k
            </li>
            <li>
              خروجی: عضو kاُم مجموعه S (از کوچک به بزرگ)
            </li>
            <li>
              الف. S را به ستون‌های ۵ تایی افراز می‌کنیم (یکی مجموعه ممکن است کمتر از ۵ عضو داشته باشد). (زمان: Θ(1))
            </li>
            <li>
              ب. هر ستون ۵ تایی را مرتب می‌کنیم. (زمان: Θ(n))
            </li>
            <li>
              پ . میانۀ سطر وسط را با استفاده از همین الگوریتم پیدا می‌کنیم و آن را x می‌نامیم. (زمان: (T(n/5)
            </li>
            <li>
              ت. عناصر S را به سه مجموعۀ L (عناصر کوچک‌تر از E ،(x (عناصر برابر با x) و G (عناصر بزرگ‌تر از x) تقسیم
              می‌کنیم. (زمان: (Θ(n)
            </li>
            <li>
              ث. بر اساس مقدار k در یکی از این سه مجموعه به صورت بازگشتی به دنبال عنصر موردنظر (با k جدید) می‌گردیم.
              (زمان: (T(7n/10)
            </li>
          </ul>
          <li>
            تقسیم بر اساس میانۀ سطر تضمین می‌کند اندازۀ هر کدام از L و G حداقل 3n/10 و حداکثر 7n/10 است (اگر دقیق
            بخواهیم حساب کنیم حدود ۶ تا کمتر یا بیشتر از این مقدار است).
          </li>
          <li>
            زمان اجرای الگوریتم میانۀ میانه‌ها:
            (T(n) = Θ(n) + T(n/5) + T(7n/10) = Θ(n
          </li>
          <li>
            با وجود زمان اجرای خطی این الگوریتم، به علت ضریب بالا از آن در عمل استفاده نمی‌شود.
          </li>
        </ul>
		        </ul>
        </ul>
          <ul>
            <li>
              الگوریتم‌های تصادفی
            </li>
            <ul>
              <li>
                تعریف: الگوریتم‌هایی هستند که یک عدد تصادفی {r∈{1,2,...,R تولید کرده و بر اساس این مقدار الگوریتم را
                اجرا می‌کنند.
              </li>
              <li>
                بنابراین اجراهای مختلف الگوریتم روی یک ورودی یکسان، می‌تواند با هم متفاوت باشند. این تفاوت یا در تعداد
                مراحل است (یک بار سریع و یک بار کند) یا در خروجی (یک بار خروجی خوب و یک بار خروجی بد که حتی ممکن است
                اشتباه باشد - باید احتمال تولید خروجی اشتباه خیلی کم باشد).
              </li>
              <li>
                الگوریتم‌های احتمالاً درست:
                به الگوریتم‌های مونت‌کارلو معروف هستند. درستی خروجی الگوریتم احتمالی است ولی همیشه سریع است.
              </li>
              <ul>
                <li>
                  مثال: الگوریتم بررسی اول بودن یک عدد، الگوریتم بررسی درست بودن ضرب ماتریس،شبیه سازی فرآیندهای فیزیکی،3D Rendering  و ...
                </li>
              </ul>
              <li>
                الگوریتم‌های احتمالاً سریع:
                به الگوریتم‌های لاس‌وگاس معروف هستند. خروجی الگوریتم همیشه درست است ولی سریع بودن آن احتمالی است.
              </li>
              <ul>
                <li>
                  مثال: مرتب‌سازی سریع تصادفی
                </li>
              </ul>
              <li>
                الگوریتم‌های احتمالاً درست و احتمالاً سریع: الگوریتم‌های آتلانتیک که زیاد مورد توجه نیستند و در مراجع
                مطرح نمی‌شوند.
              </li>
            </ul>
			<li>
			ادامۀ انواع مرتب‌سازی سریع
			</li>
			<ul>
			              <li>
            ۳. مرتب‌سازی سریع تصادفی:
            عنصر لولا را به صورت تصادفی (با احتمال مساوی بین عناصر A) انتخاب می‌کنیم.
        </li>
        <ul>
          <li>
            بسیار ساده و در عین حال کارا
          </li>
          <li>
            مثالی از الگوریتم‌های لاس‌وگاس است زیرا همیشه مرتب‌سازی را به درستی انجام می‌دهد ولی زمان اجرای بر اساس
            انتخاب لولا می‌تواند کم و زیاد شود.
          </li>
          <li>
            امید ریاضی زمان اجرای آن برای ورودی دلخواه (Θ(n log n است. برای اثبات اصلی به کتاب CLRS مراجعه شود. ما در
            این جلسه همین زمان اجرا را برای الگوریتم مرتب‌سازی سریع تصادفی وسواسی اثبات می‌کنیم.
          </li>
      </ul>
	  <ul>
      <li>
        مرتب‌سازی سریع تصادفی وسواسی
      </li>
      <ul>
        <li>
          لولا را به صورت تصادفی انتخاب کرده و تقسیم را انجام می‌دهیم. اگر اندازۀ هر دوی L و G
          حداقل n/4 بود ادامه می‌دهیم وگرنه لولا را دوباره به صورت تصادفی انتخاب می‌کنیم.
        </li>
        <li>
          امید ریاضی تعداد تکرار انتخاب لولا با احتمال 1/2 درستی لولا طبق توزیع هندسی 2 است.
        </li>
        <li>
          زمان اجرا: (T(n) = #iterations.Θ(n) + T(n/4) + T(3n/4
        </li>
        <li>
          با اِعمال امید ریاضی:
          [(E[T(n)] = E[#iterations].Θ(n) + E[T(n/4)] + E[T(3n/4
          و با توجه به این که E[#iterations]=2 و حل رابطۀ بازگشتی برای [(E[T(n داریم:
        </li>
        <li>
          (E[T(n)] = Θ(n log n
        </li>
      </ul>
    </ul>
    </p>
  </div>
</body>

</html>
