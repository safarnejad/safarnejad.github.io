<!DOCTYPE html>
<html dir="rtl" lang="fa">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ یازدهم</title>

  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css" />
	<link rel="stylesheet" href="css/syntax.css" type="text/css" />
  	<link rel="stylesheet" href="css/main.css" type="text/css" />

  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop"> جلسۀ یازدهم (دوشنبه ۲۶ اسفند ۹۸)</h3><br/>
<p class="myjustify">
<ul>
<li>
در این جلسه کران پایین (Ω(n log n را برای زمان هر مرتب‌سازی اثبات می‌کنیم.
</li>
<li>
مدل مقایسه:
</li>
<ul>
<li>
عناصر در این مدل واسط‌هایی هستند که فقط با هم می‌توانند مقایسه شوند.
</li>
<li>
زمان در این مدل برابر با تعداد مقایسه‌ها است.
</li>
<ul>
<li>
توجه کنید که در این مدل از عملیات مختلف الگوریتم غیر از مقایسه صرف‌نظر می‌شود، با این حال این ساده‌سازی برای اثبات کران پایین مشکلی ایجاد نمی‌کند.
</li>
</ul>
<li>
مرتب‌سازی‌هایی که تا الان در این کلاس دیدیم بجز binary_insertion_sortبا این مدل سازگار هستند (فقط از مقایسۀ عناصر استفاده کرده‌اند).
</li>
</ul>
<li>
درخت تصمیم:
</li>
<ul>
<li>
می‌توان به هر الگوریتم مبتنی بر مقایسه برای یک اندازه ورودی (n) خاص یک درخت تصمیم معادل آن نسبت داد.
</li>
<li>
این درخت واقعاً برای نمایش و کشیدن نیست و یک مفهموم انتزاعی است که بیشتر در اثبات‌های ریاضی کاربرد دارد.
</li>
<li>
درخت تصمیم مدل تفکری است که تمام مقایسه‌های ممکن و نتیجه‌های ممکن آن‌ها را به صورت یک‌جا به تصویر می‌کشد.
</li>
<li>
کاربرد درخت تصمیم به الگوریتم‌های مبتنی بر مقایسه محدود نمی‌شود.
</li>
<li>
مقایسه درخت تصمیم و الگوریتم (در مدل مقایسه):
</li>
<ul>
<li>
رأس داخلی در درخت ≡ یک تصمیم دودویی (این‌جا مقایسه) در الگوریتم
</li>
<li>
برگ در درخت ≡ جواب پیدا شده در الگوریتم
</li>
<li>
یک مسیر از ریشه به برگ  در درخت ≡ یک بار اجرای الگوریتم
</li>
<li>
طول مسیر از ریشه به برگ در درخت ≡ زمان یک بار اجرای الگوریتم
</li>
<li>
ارتفاع درخت ≡ زمان اجرای الگوریتم در بدترین حالت
</li>
</ul>
</ul>
<li>
کران پایین جست‌وجو
</li>
<ul>
<li>
 n عنصر پیش‌پردازش شده داریم. پیدا کردن یک عنصر در آن‌ها در مدل مقایسه به زمان
 <span dir="ltr">Ω(log n)</span>
  در بدترین حالت نیاز دارد.
</li>
<li>
اثبات:
</li>
<ul>
<li>
درخت تصمیم دودویی است.
</li>
<li>
درخت تصمیم باید حداقل n برگ داشته باشد (یک برگ برای هر جواب - در واقع ممکن است چند برگ برای یک جواب هم وجود داشته باشد).
</li>
<li>
 بنابراین ارتفاع درخت (Ω(log n است که معادل زمان الگوریتم در بدترین حالت است.
</li>
</ul>
<li>
در نتیجه جست‌وجوی دودویی روی آرایه و درخت‌های دودویی جست‌وجوی متوازن (مثل درخت قرمز-سیاه و درخت ای‌وی‌ال) بهینه هستند.
</li>
</ul>
<li>
کران پایین مرتب‌سازی:
</li>
<ul>
<li>
روند اثبات مشابه است. مثل حالت قبل درخت دودویی هست.
</li>
<li>
تعداد برگ‌ها حداقل به اندازه تعداد جواب‌هاست و بنابراین در هر برگ باید ترتیب عناصر را بدانیم. بنابراین تعداد برگ‌ها حداقل !n است.
</li>
<li>
می‌توان نتیجه گرفت که ارتفاع درخت و معادل آن زمان اجرای هر الگوریتم مرتب‌سازی در بدترین حالت
 (در مدل مقایسه) ((!Ω(log (n است.
</li>
<li>
به دو روش می‌توان نشان داد که (Θ(log (n!)) = Θ(n log n.
</li>
<ul>
<li>
روش اول:
(log (n!) = Σ<sub style="left:1px; top:4px">i=1</sub><sup style="left:-14px; top:-7px">n</sup>log i > (n/2) log(n/2) = Ω(n log n
</li>
<li>
روش دوم (تقریب استرلینگ):
(log (n!) ≃ log[√<span style="text-decoration:overline">2πn</span> (n/e)<sup>n</sup>] = n log n - n + O(log n) = Θ(n log n
</li>
</ul>
<li>
در نتیجه مرتب‌سازی‌های ادغامی، هرمی، ای‌وی‌ال، قرمز-سیاه و سریع با انتخاب هوشمندانه لولا (به صورت مجانبی و در مدل مقایسه) بهینه هستند.
</li>
<li>
توجه کنید n log n و (!log (n با هم اختلاف اندکی دارند. در صورت علاقه به مرتب‌سازی با کمترین تعداد مقایسه می‌توانید
الگوریتم فورد-جانسون را از کتاب دکتر قدسی مطالعه کنید.
</li>
</ul>
</ul>
</p>
</div>
</body>
</html>
