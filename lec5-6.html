<html dir="rtl" lang="fa"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ پنجم</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css">
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css">
	<link rel="stylesheet" href="css/syntax.css" type="text/css">
  	<link rel="stylesheet" href="css/main.css" type="text/css">
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ پنجم (شنبه ۳ اسفند ۹۸)</h3><br>
<p class="myjustify">
</p>
      <ul>
          <li>
اولین جلسه با موضوع داده ساختار
</li>
<li>
واسط (interface) یا داده گونۀ انتزاعی
</li>
<li>
تفاوت واسط با داده‌ساختار
</li>
<ul>
<li>
واسط: مشخصات / چه داده‌هایی نگه‌داری شوند / چه عملیاتی روی آن‌ها انجام می‌شود / در واقع صورت مسئله / برخورد جعبه سیاه
</li>
<li>
داده ساختار: پیاده‌سازی / چگونه داده‌ها نگه‌داری می‌شوند / الگوریتم‌هایی که بر روی آن‌ها انجام می‌شوند / در واقع راه‌حل مسئله / برخورد جعبه سفید
</li>
</ul>
<li>
دو واسط در این درس بررسی می‌شوند:
</li>
<ul>
<li>
دنباله‌ای (جلسۀ امروز)
</li>
<li>
مجموعه‌ای (جلسۀ بعد تا عید)
</li>
</ul>
<li>
داده‌ساختارهای مربوط به واسط دنباله‌ای:
</li>
<ul>
<li>
مبتنی بر آرایه
</li>
<li>مبتنی بر لیست پیوندی
</li>
</ul>
<li>
واسط دنبالۀ ایستا: یک دنباله n تایی از اشیا را نگهداری میکند و عملیات زیر را پشتیبانی می کند :
</li>
<ul>
<li>
<div>
 ()len : طول دنباله را برمی‌گرداند O(1)
</div>
</li>
<li>
<div>
()seq-iter : دنباله را خروجی می دهد O(n)
</div>

</li>
<li>
<div class="mycode" dir="ltr">
at(i) / left() / right() **
</div>
    <p>
    شئ با اندیس i را خروجی می دهد O(1)
    </p>
    
</li>
<li>
<div class="mycode" dir="ltr">
set-at(i, x) **
</div>
</li>
    <li>
        توجه شود که دو عمل ** برای لیست پیوندی سخت است.
    </li>
</ul>
<li>
آرایۀ ایستا: راه‌حلی برای واسط دنباله ایستا (منظور از ایستا بودن این است که از ابتدا حافظه آن به طول n مشخص شده است.‌)
</li>
<li>
واسط دنبالۀ پویا:
</li>
<ul>
<li>
عملیات دنباله ایستا به علاوۀ
</li>
<li>
<div class="mycode" dir="ltr">
insert-at(i,x) / insert-left(x) / insert-right(x)
</div>
</li>
<li>
<div class="mycode" dir="ltr">
delete-at(i) / delete-left() / delete-right
</div>
    <p>
        بعد از انجام عملیات حذف بقیه اعضا shift داده می شوند.
    </p>
</li>
</ul>
<li>
پیاده‌سازی دنباله پویا با تمام امکانات بدون درخت میسر نیست. بنابراین واسط‌های پرکاربرد زیر مورد توجه قرار گرفتند: (حالت های خاص واسط دنباله‌ی پویا)
</li>
<ul>
<li>
پشته (stack) با عملیات
</li>
<ul>
<li>
<div class="mycode" dir="ltr">
top() ≡ right()
</div>
    <p>
        O(1)
    </p>
</li>
<li>
<div class="mycode" dir="ltr">
push() ≡ insert-right()
</div>
    <p>
        O(1)
    </p>
</li>
<li>
<div class="mycode" dir="ltr">
pop() ≡ delete-right()
</div>
    <p>
        O(1)
    </p>
</li>
</ul>
<li>
صف [یک طرفه] (queue) با عملیات:
</li>
<ul>
<li>
<div class="mycode" dir="ltr">
enqueue() ≡ insert-right()
</div>
    <p>
        O(1)
    </p>
</li>
<li>
<div class="mycode" dir="ltr">
dequeue() ≡ delete-left()
</div>
    <p>
        O(1)
    </p>
</li>
</ul>
<li>
صف دو طرفه (dequeue) با عملیات:
</li>
<ul>
<li>
<div class="mycode" dir="ltr">
insert/delete - left/right ()
</div>
    <p>
        O(1)
    </p>
</li>
</ul></ul>
<li>
آرایه‌های ایستا برای این عملیات مناسب نیستند.
</li>
<li>
یک راه‌حل، استفاده از لیست‌های پیوندی است.
</li>
<ul>
<li>
حافظه مربوط به هر شیء را جداگانه اختصاص می‌دهیم (در مقابل آرایه و در مکان های مختلف RAM)
</li>
<li>
با اشاره‌گرهایی این حافظه‌ها را به هم متصل می‌کنیم.
</li>



</ul>
<li>
آرایه‌های پویا (در پایتون list و در سی‌پلاس‌پلاس vector و در جاوا ArrayList)
</li>
<ul>
<li>
اجازه می‌دهیم اندازۀ آرایه به جای n، از (Θ(n باشد.
</li>
<li>
هر وقت آرایه پر شد، طول آن را دو برابر می‌کنیم.
</li>
<li>
وقتی عملیات
<span class="mycode" dir="ltr">insert-right()</span>
انجام می‌دهیم، ممکن است (Θ(n طول بکشد، اما این اتفاق تنها برای وقتی n توانی از ۲ است اتفاق می‌افتد.
</li>
<li>
در مجموع n عملیات درج، (Θ(n و بنابراین به صورت سرشکن (Θ(1 طول می‌کشد.
</li>
</ul>
<li>
تحلیل سرشکن
</li>
<ul>
<li>
در این جلسه معرفی می‌شود و در جلسۀ ۱۹ به طور دقیق‌تر بررسی می‌شود.
</li>
<li>
مشابه سرشکن کردن اجاره ماهانه به روزانه
</li>
<li>
به طور دقیق‌تر می‌گویم یک عمل به طور سرشکن (T(n طول می‌کشد اگر k  بار اجرای آن (k.T(n طول بکشد.
</li>
</ul>
<li>
اگر عمل 
<span class="mycode" dir="ltr">delete-right()</span>
را بدون تغییر اندازۀ آرایه انجام دهیم، ممکن است حافظه دیگر (Θ(n نباشد.
</li>
<li>
وقتی اعضا یک چهارم طول آرایه شدند، آرایه را نصف می‌کنیم. (هر عدد ثابت بزرگ‌تر از ۲ را می‌توان به جای ۴ قرار داد)
</li>
<li>
عملیات 
<span class="mycode" dir="ltr">insert-left()</span>
و
<span class="mycode" dir="ltr">delete-left()</span>
در تمرین بعدی بررسی می‌شوند.
</li>
<li>
 واسط‌های مجموعه‌ای که داده‌ساختارهای آن در جلسات بعد بررسی می‌شوند: (یک مجموعه S از اشیا را نگه می‌دارد که هر شئ یک کلید دارد.)
</li>
<ul>
<li>
واسط مجموعه‌ای (ساده یا ایستا)
</li>
<ul>
<li>
<span class="mycode" dir="ltr">find-key(k)</span>
    <p>شئ با کلید k را در صورت وجود برگردان
    </p>
</li>
<li>
<span class="mycode" dir="ltr">iter()</span>
</li>
    <p>
        به ترتیب دلخواه اعضای مجموعه را برگردان
    </p>
</ul>
<li>
واسط مجموعه‌ای پویا
</li>
<ul>
<li>
عملیات مجموعۀ ایستا به علاوۀ
</li>
<li>
<span class="mycode" dir="ltr">insert(k, x)</span>
    <p>
        x را به مجموعه S اضافه می کندو در صورت وجود شئ با کلید k ، شئ قبل حدف می شود
    </p>
</li>
<li>
<span class="mycode" dir="ltr">delete-key(k)</span>
    <p>
        شئ x عضو S را که x.key = k است را در صورت وجود حذف می کند
    </p>
</li>
</ul>
<li>
واسط مجموعه‌ای ایستای مرتب
</li>
<ul>
<li>
عملیات مجموعۀ ایستا به علاوۀ
</li>
<li>
<span class="mycode" dir="ltr">find-next(k)</span>
    <p>
        x عضو S را پیدا کن با حداقل کلید بزرگتر از k
    </p>
</li>
<li>
<span class="mycode" dir="ltr">find-prev(k)</span>
    <p>
        x عضو S را پیدا کن با حداکثر کلید کوچکتر از k
    </p>
</li>
<li>
<span class="mycode" dir="ltr">find-min(k) ≡ find-next(-∞)</span>
    <p>
        x عضو S با کوچکترین کلید
    </p>
</li>
<li>
<span class="mycode" dir="ltr">find-max(k) ≡ find-prev(∞)</span>
    <p>
                x عضو S با بزرگترین کلید

    </p>
</li>
    
<li>
<span class="mycode" dir="ltr">order-iter(k)</span>
    <p>
        مرتب کردن S بر حسب کلید
    </p>
</li>
</ul>
<li>
واسط مجموعه‌ای پویا و مرتب
</li>
<ul>
<li>
عملیات مجموعۀ پویا و عملیات مجموعۀ مرتب به علاوۀ
</li>
<li>
<span class="mycode" dir="ltr">delete-min(k)</span>
</li>
<li>
<span class="mycode" dir="ltr">delete-max(k)</span>
</li>
</ul><li>
    درخت در داده ساختار
    <ul>
        <li>
            درخت ریشه دار یا بدون ریشه
        </li>
        <li>
            تعریف ریشه، راس های داخلی و برگ/آویز در درخت
        </li>
        <li>
            تفاوت درخت مرتب و غیر مرتب (اهمیت ترتیب فرزندان)
        </li>
        <li>
            تعریف زیردرخت یک راس : درخت به ریشه b و شامل b و فرزندان و نوادگان b
        </li>
        <li>
            ارتفاع درخت، ارتفاع هر راس و عمق هر راس
        </li>
        <li>
            مثال هایی از کاربرد درخت : directory ، فایل های xml، فایل های JSON، یکی از ساختارهای پیشنهادی برای تبدیل RNA به DNA
        </li>
        <li>
            درخت دودویی یا غیر دودویی
        </li>
        <li>
            درخت دودویی تقریبا کامل، مثال آن و تفاوت آن با درخت کامل
        </li>
        <ul>
<li>
<div class="mycode" dir="ltr">
parent(i) = ⌊(i-1)/2⌋
</div>
</li>
<li>
<div class="mycode" dir="ltr">
left(i) = 2*i+1
</div>
</li>
<li>
<div class="mycode" dir="ltr">
right(i) = 2*i+2
</div>
</li>
<li>
ارتفاع درخت تقریباً 
<span class="mycode" dir="ltr">⌊log<sub>2</sub>(i+1)⌋</span> 
 است.
</li>
</ul>
        
    </ul>
</li>
<li>
واسط صف اولویت - موضوع جلسۀ بعد
</li>
</ul>


      </ul>
      
    
    </div>
</body></html>