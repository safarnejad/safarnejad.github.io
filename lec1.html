<html dir="rtl" lang="fa"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جلسۀ اول</title>
  	
  	<link rel="stylesheet" href="css/bootstrap.css" type="text/css">
  	<link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css">
	<link rel="stylesheet" href="css/syntax.css" type="text/css">
  	<link rel="stylesheet" href="css/main.css" type="text/css">
  
  	<script src="js/jquery-1.11.0.min.js"></script>
  	<script src="js/bootstrap.min.js"></script>
</head>

<body>
  <div id="page" class="container mynarrow">
      <h3 class="nomargintop">جلسۀ اول (شنبه ۱۹ بهمن ۹۸)</h3><br>
<p class="myjustify">
</p><ul>
<li>
موضوع درس: روند‌های بهینه برای حل مسائل با مقیاس نسبتاً بزرگ در کنار تحلیل و طراحی این روندها.
</li>
<li>
    معیارهای بهینه‌بودن: درستی، سرعت، فضای کم، کلی بودن، سادگی و خلاقانه بودن.
</li>
<li>
    معیار بزرگ بودن در طول زمان فرق کرده است. مثال‌هایی از داده‌های بزرگ: نقشه‌های شهری و بین‌شهری، ژنوم انسان و شبکه‌های اجتماعی.
</li>
<li>
    تعریف مقیاس‌پذیری یک روش.
</li>
<li>
    تعریف «تست زمان» و علت قدیمی بودن برخی مطالب درس.
</li>
<li>
تأکید این درس بر تحلیل است و درس بعد از این که طراحی الگوریتم‌ها است بیشتر به طراحی می‌پردازد.
</li>
<li>
    مرور عناوین درسی: تفکر الگوریتمی، مرتب‌سازی، درخت‌ها، درهم‌سازی، اعداد بزرگ، دیگر داده‌ساختارها، گراف‌ها و مباحث پیشرفته.
</li>
<li>
    مسئلۀ پیدا کردن قله: پیدا کردن بیشینۀ محلی در یک آرایۀ یک بعدی و یا دو بعدی (منظور از قله خانه ای است که از دو خانه ی مجاور خود در صورت وجود بیشتر یا مساوی باشد).
</li>
<li>
    راه اول یک بعدی: بررسی تمام خانه‌ها
</li>
<li>
    راه دوم یک بعدی: شروع از یک سمت یا وسط آرایه و حرکت تا جایی که به قله برسیم. حداکثر n خانه دیده می‌شود.
</li>
<li>
    راه سوم یک بعدی: شروع از خانۀ وسط و اگر قله نبود مسئله را نصف می‌کنیم. حداکثر حدود 3log<sub>2</sub>n خانه پرسیده می‌شود.
</li>
<li>
    راه اول دو بعدی: شروع از یک خانه و حرکت به سمت بزرگ‌ترین خانۀ مجاور. ممکن است نزدیک به نصف خانه‌ها دیده شود.
</li>
<li>
    راه دوم دو بعدی: در ستون وسط قله‌ای را با الگوریتم یک بعدی پیدا کرده و در سطر آن نیز یک قلۀ یک بعدی پیدا کنیم و آن را خروجی می‌دهیم. الگوریتم سریع ولی غلط است. درست بودن بهتر است یا سریع بودن؟ معرفی الگوریتم‌های مکاشفه‌ای.
</li>
<li>
    راه سوم دو بعدی: بیشینه هر ستون را پیدا کرده و در یک لیست بریزیم و سپس قله را با استفاده از راه سوم یک بعدی پیدا کنیم. حداکثر در حدود
n<sup>2</sup>
    خانه دیده می‌شود.
</li>
<li>
    راه چهارم دو بعدی: بیشینه هر ستون را هنگام نیاز محاسبه کنیم. حداکثر در حدود 3nlog<sub>2</sub>n خانه دیده می‌شود.
</li>
<li>
    راه پنجم دو بعدی: در یک ستون عنصر بیشینه را پیدا می‌کنیم و اگر قله نبود مسئله را نصف می‌کنیم. حداکثر در حدود nlog<sub>2</sub>n خانه دیده می‌شود.
</li>
<li>
    راه ششم دو بعدی: الگوریتم قبلی را یک بار برای سطر و یک بار برای ستون اجرا می‌کنیم. حداکثر در حدود 3n خانه دیده می‌شود.
</li>
</ul></div>


</body></html>
